#+STARTUP: overview

* WEEK #1
** keywords
- data modeling
- NoSQL
- primary keys, foreign keys
- ER diagrams: Chen notation, Crow's foot notation, UML class diagram notation
** installation
- for Linux: install sqlite3 from terminal
** commands
*** select
  simple select query
  #+begin_src sql
	    select col1, col2, col3 from my_table limit number_of_lines;
  #+end_src
  limit the number of rows
  #+begin_src sql
	    select col1, col2, col3 from my_table where col4 = 'value';
  #+end_src
  sum of a column
  #+begin_src sql
	    select sum(col1) from my_table;
  #+end_src
*** create table
  #+begin_src sql
    create table my_table
	   (col1 char(20) null,
	   col2 char(20) not null,
	   col3 char(20) primary key);
  #+end_src
*** insert into table
  #+begin_src sql
	    /* It's a good practice to first
	    identify columns that the values
	     are going to get there */
    insert into my_table
	   (col1, col2, )
	   values
	   (value1, value2,);		
  #+end_src
*** create temporary table
  #+begin_src sql
	    -- create a subset from a table
    create temporary table my_tmp_table as
	   (
	   select *
	   from my_table
	   where col1 = 'value')
  #+end_src
*** adding comments by -- and /**/
*** open a database
#+begin_src sql
	  .open database_name.db
#+end_src
** articles
- [[https://aws.amazon.com/what-is/sql/][AWS and SQL]]
- [[https://www.w3resource.com/sqlite/index.php][Sqlite toturials]]
- [[https://dataconomy.com/2014/07/01/sql-vs-nosql-need-know/][SQL vs. NoSQL â€“ Know the Difference]]
- [[https://www.techrepublic.com/article/nosql-keeps-rising-but-relational-databases-still-dominate-big-data/][NoSQL keeps rising, but relational databases still dominate big data]]
- 
* WEEK #2: Filtering sorting and calculating data with SQL
** Introduction
*** Clauses and operators
- WHERE
- BETWEEN
- IN
- OR
- NOT
- LIKE
- ORDER BY
- GROUP BY
*** Wildcards
*** Math operators
- AVERAGE
- COUNT
- MAX
- MIN
** Basics of Filtering with SQL
*** where clause operator
#+begin_src sql
  SELECT col1, col2 FROM my_table
	 WHERE col operator value;
#+end_src
operator can be
- =
- <> (not equal !=)
- <
- >
- >=
- <=
- BETWEEN AND
- IS NULL
** Advanced Filtering: IN, OR, and NOT
*** IN
- use parentheses for more than one condition with comma between them
*** OR
| WHERE | X     | or | Y     | condition |
|-------+-------+----+-------+-----------|
|       | true  | or | false | X         |
|       | true  | or | true  | X         |
|       | false | or | false | nil       |
|       | false | or | true  | Y         |
*** IN or OR
- in is faster
- or: order is important
- in: order is not important
- in: making sub-queries
*** OR  AND
| WHERE | X | OR | Y | AND | Z | condition |
|-------+---+----+---+-----+---+-----------|
|       | T |    | F |     | F | X         |
OR is executed before AND. By using parentheses we can force to check
AND condition:
| WHERE | (X | OR | Y) | AND | Z | condition |
|-------+----+----+----+-----+---+-----------|
|       | T  |    | F  |     | F | nil       |
** Using Wildcards in SQL
*** LIKE operator(predicate)
Used for only string data not numerical data. 
- %: '%string', 'st%g', 'st%'
  it does not match NULL value
- _: is not supported in DB2 but most other system support it.
  #+begin_src sql
	    WHERE val LIKE '_string'
  #+end_src
- []: not supported in SQLite
- Wildcards are slower than filtering operators 
** ORDER BY
- It should be the last clause in an statement
- Different columns can be used for sorting
- Column position can be used
  #+begin_src sql
    ORDER BY 1,5
  #+end_src
- DESC: descending
- ASC: ascending
- DESC and ASC should be repeated for each column
** Math Operations
Creating new column in the output from math operations on other
columns:
#+begin_src sql
  SELECT col1,col2, col1*col2 AS new_col
	 FROM my_table;
#+end_src
new_col is as alias for the new column 
** Aggregate Functions
- AVG()
- COUNT()
- MIN()
- MAX()
- SUM()
#+begin_src sql
  SELECT AVG(col1) AS col1_avg FROM my_table;
	 -- null rows are ignored 
#+end_src
#+begin_src sql
  SELECT count(*) AS total_rows FROM my_table;
	 -- it counts null rows
	 -- if you count a specific column, it ignores null rows
#+end_src
*** DISTINCT
It recognizes duplicates in a column
#+begin_src sql
  SELECT count(DISTINCT col1)
	 FROM my_table
#+end_src
