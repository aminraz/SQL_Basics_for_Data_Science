#+STARTUP: overview
#+OPTIONS: toc:2
 
This file includes notes and summary of the course [[https://www.coursera.org/learn/sql-for-data-science][SQL for Data
Science]] from University of California, Davis available in Coursera
as well as additional information that I find useful to learn but it's
missing in the course. You can use it as a supplementary material if
you're taking the course or as an standalone summary of basics of SQL
for data science.

You are encouraged to download the README.org and open it inside Emacs
if you're familiar with org mode. It has the same content.

* Sample Database
Download the sample database called chinook from this [[https://www.sqlitetutorial.net/sqlite-sample-database/][link]].
** see columns in a sample table
#+begin_src sql
	  select * from genres; 
#+end_src
* General Commands
- open the database
  #+begin_src sql
	  .open chinook.db
#+end_src
- inspect the tables
  #+begin_src sql
	  .tables
#+end_src
- .help: show help for dot commands
- .database: show the connected databases in the session
- attach a database
  #+begin_src sql
	    attach database "address.db" as db_name;
  #+end_src
- .exit: exit the sqlite
- showing the structure of a table
  #+begin_src sql
	    .schema tab_name
  #+end_src
- .indexes: show the indexes of the current database or table
- write query result into a file
  #+begin_src sql
    .output filename
	    select * from tab_name;
  #+end_src
* WEEK #1
** keywords
- data modeling
- NoSQL
- primary keys, foreign keys
- ER diagrams: Chen notation, Crow's foot notation, UML class diagram notation
** installation
- for Linux: install sqlite3 from terminal
** commands
*** select
  simple select query
  #+begin_src sql
	    select col1, col2, col3 from my_table limit number_of_lines;
  #+end_src
  limit the number of rows
  #+begin_src sql
	    select col1, col2, col3 from my_table where col4 = 'value';
  #+end_src
  sum of a column
  #+begin_src sql
	    select sum(col1) from my_table;
  #+end_src
*** create table
  #+begin_src sql
    create table my_table
	   (col1 char(20) null,
	   col2 char(20) not null,
	   col3 char(20) primary key);
  #+end_src
*** insert into table
  #+begin_src sql
	    /* It's a good practice to first
	    identify columns that the values
	     are going to get there */
    insert into my_table
	   (col1, col2, )
	   values
	   (value1, value2,);		
  #+end_src
*** create temporary table
  #+begin_src sql
	    -- create a subset from a table
    create temporary table my_tmp_table as
	   (
	   select *
	   from my_table
	   where col1 = 'value')
  #+end_src
*** adding comments by -- and /**/
** articles
- [[https://aws.amazon.com/what-is/sql/][AWS and SQL]]
- [[https://www.w3resource.com/sqlite/index.php][Sqlite toturials]]
- [[https://dataconomy.com/2014/07/01/sql-vs-nosql-need-know/][SQL vs. NoSQL â€“ Know the Difference]]
- [[https://www.techrepublic.com/article/nosql-keeps-rising-but-relational-databases-still-dominate-big-data/][NoSQL keeps rising, but relational databases still dominate big data]]
- 
* WEEK #2
Filtering sorting and calculating data with SQL
** Introduction
*** Clauses and operators
- WHERE
- BETWEEN AND
- IN
- OR
- NOT
- LIKE
- ORDER BY
- GROUP BY
*** Wildcards
*** Math operators
- AVERAGE
- COUNT
- MAX
- MIN
** Basics of Filtering with SQL
*** where clause operator
#+begin_src sql
  SELECT col1, col2 FROM my_table
	 WHERE col operator value;
#+end_src
operator can be
- =
- <> (not equal !=)
- <
- >
- >=
- <=
- BETWEEN AND
- IS NULL
*** BETWEEN AND
#+begin_src sql
  select city from customers where customerid between 4 and 10;	
#+end_src
** Advanced Filtering: IN, OR, and NOT
*** IN
- use parentheses for more than one condition with comma between them
  #+begin_src sql
    select country from customers where city in ('Paris', 'Rome', 'Oslo');		
  #+end_src
*** OR
| WHERE | X     | or | Y     | output |
|-------+-------+----+-------+--------|
|       | true  | or | false | X      |
|       | true  | or | true  | X      |
|       | false | or | false | nil    |
|       | false | or | true  | Y      |
*** IN or OR
- IN is faster
- OR: order is important
- IN: order is not important
- IN: making sub-queries
*** OR  AND
| WHERE | X | OR | Y | AND | Z | output |
|-------+---+----+---+-----+---+--------|
|       | T |    | F |     | F | X      |
OR is executed before AND. By using parentheses we can force to check
AND condition:
| WHERE | (X | OR | Y) | AND | Z | output |
|-------+----+----+----+-----+---+--------|
|       | T  |    | F  |     | F | nil    |
** Using Wildcards in SQL
*** LIKE operator(predicate)
Used for only string data not numerical data. 
- %: '%string', 'st%g', 'st%'
  it does not match NULL value
- _: is not supported in DB2 but most other system support it.
  #+begin_src sql
	    WHERE val LIKE '_string'
  #+end_src
- []: not supported in SQLite
- Wildcards are slower than filtering operators 
** ORDER BY
- It should be the last clause in an statement
- Different columns can be used for sorting
- Column position can be used
  #+begin_src sql
    ORDER BY 1,5
  #+end_src
- DESC: descending
- ASC: ascending
- DESC and ASC should be repeated for each column
** Math Operations
Creating new column in the output from math operations on other
columns:
#+begin_src sql
  SELECT col1,col2, col1*col2 AS new_col
	 FROM my_table;
#+end_src
new_col is as alias for the new column 
** Aggregate Functions
- AVG()
- COUNT()
- MIN()
- MAX()
- SUM()
#+begin_src sql
  SELECT AVG(col1) AS col1_avg FROM my_table;
	 -- null rows are ignored 
#+end_src
#+begin_src sql
  SELECT count(*) AS total_rows FROM my_table;
	 -- it counts null rows
	 -- if you count a specific column, it ignores null rows
#+end_src
AS is not mandatory.

*** DISTINCT
It recognizes duplicates in a column
#+begin_src sql
  SELECT count(DISTINCT col1)
	 FROM my_table
#+end_src
** Grouping Data with SQL
*** GROUP BY
  In the following example we are counting the number of cities each
  country has in our table customers:
  #+begin_src sql
    select country, count(city) from customers group by country ;	
  #+end_src
*** HAVING
  It filters the result of group by like where. In the following
  example, the result is filtered to those countries with customers
  having a special email patter: 
  #+begin_src sql
    select country, count(city) from customers group by country having  email like '%com';	
  #+end_src
  We can use multiple columns for group by. If there are more columns
  in the group by, these groups need to be in the select part
  too. NULL is categorized separately.

  WHERE is used before grouping and HAVING is used after it. 
* WEEK #3
** Using Subqueries
They are used to create queries inside queries.
#+begin_src sql
	      select country, company from customers
	      where customerid in
	      (select customerid from invoices where billingstate like 'a%');
#+end_src
** Subquery Best Practices and Considerations
Format your code using [[https://poorsql.com/][poorsql.com]]
** Joins
*** selecting from different tables
#+begin_src sql
SELECT orders.order_id, customers.customer_name
FROM orders
INNER JOIN customers ON orders.customer_id = customers.customer_id;

#+end_src
The dot (.) in orders.order_id and customers.customer_name is used to
specify the table from which each column should be retrieved. This
notation is often referred to as "table.column" notation, and it's
necessary when you are selecting columns from multiple tables that
have columns with the same name.
*** inner join
#+begin_src sql
SELECT orders.order_id, customers.customer_name
FROM orders
INNER JOIN customers ON orders.customer_id = customers.customer_id;

#+end_src

1. `SELECT orders.order_id, customers.customer_name`: This part of the SQL statement specifies the columns you want to retrieve in the result set. It's saying that you want to retrieve two columns:
   - `orders.order_id`: This is the `order_id` column from the `orders` table.
   - `customers.customer_name`: This is the `customer_name` column from the `customers` table.

2. `FROM orders`: This part of the statement specifies the source table from which you want to retrieve data. In this case, it's the `orders` table.

3. `INNER JOIN customers ON orders.customer_id = customers.customer_id`: This is where the actual join operation occurs. Let's break it down further:
   - `INNER JOIN`: This specifies that you want to perform an inner join between the `orders` table and the `customers` table. An inner join returns only the rows where there is a match in both tables.
   - `customers` is the name of the table you're joining with.
   - `ON orders.customer_id = customers.customer_id`: This part of the statement specifies the join condition. It tells the database how to match rows between the two tables. Specifically, it's saying that you want to join rows where the `customer_id` column in the `orders` table is equal to the `customer_id` column in the `customers` table. This condition establishes the relationship between the two tables based on the `customer_id` column.

So, when you execute this SQL statement, SQLite will retrieve data from both the `orders` and `customers` tables and combine it into a single result set. The result will include pairs of `order_id` and `customer_name` where the `customer_id` values in the `orders` and `customers` tables match.

For example, if you have the following data:

*orders table:*
| order_id | customer_id |
|----------+-------------|
|        1 |         101 |
|        2 |         102 |
|        3 |         103 |

*customers table:*
| customer_id | customer_name |
|-------------+---------------|
|         101 | Alice         |
|         102 | Bob           |
|         104 | Carol         |

The result of the SQL query will be:

| order_id | customer_name |
|----------+---------------|
|        1 | Alice         |
|        2 | Bob           |

As you can see, only the rows with matching `customer_id` values (1
and 2) are included in the result, and it combines the relevant data
from both tables.

